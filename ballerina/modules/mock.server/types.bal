// AUTO-GENERATED FILE.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/constraint;
import ballerina/data.jsondata;
import ballerina/http;

@constraint:Number {minValue: -180, maxValue: 180}
public type GeoBboxItemsNumber decimal;

# The previous token
@constraint:String {minLength: 1}
public type PreviousToken string;

# The full-content of the Tweet, including text beyond 280 characters
public type TweetNoteTweet record {
    # Entities extracted from tweet note content including mentions, hashtags, and URLs
    TweetNoteTweetEntities entities?;
    # The note content of the Tweet
    NoteTweetText text?;
};

# The number of results returned in this response
public type ResultCount int:Signed32;

# Response schema for retrieving followers of a specific user
public type Get2UsersIdFollowersResponse record {
    # Array of User objects representing the followers
    @constraint:Array {minLength: 1}
    User[] data?;
    # Metadata for paginated followers response including tokens and count
    Get2UsersIdFollowersResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects if any issues occurred during processing
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Entity representing a cashtag mention with position indices and metadata
public type CashtagEntity record {
    *EntityIndicesInclusiveExclusive;
    *CashtagFields;
};

# Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers
@constraint:String {pattern: re `^[0-9]{1,19}$`}
public type TweetId string;

# HTTP Status Code
@constraint:Int {minValue: 100, maxValue: 599}
public type HttpStatusCode int;

# Represents the Queries record for the operation: usersIdLikedTweets
public type UsersIdLikedTweetsQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # This parameter is used to get the next 'page' of results
    @http:Query {name: "pagination_token"}
    PaginationToken36 paginationToken?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # The maximum number of results
    @http:Query {name: "max_results"}
    int:Signed32 maxResults?;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
};

# Metadata for paginated response of user's liked tweets
public type Get2UsersIdLikedTweetsResponseMeta record {
    # Token for retrieving the previous page of liked tweets
    @jsondata:Name {value: "previous_token"}
    PreviousToken previousToken?;
    # Token for retrieving the next page of liked tweets
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # Number of liked tweets returned in the current response
    @jsondata:Name {value: "result_count"}
    ResultCount resultCount?;
};

# Entity representing a hashtag mention with position indices and metadata
public type HashtagEntity record {
    *EntityIndicesInclusiveExclusive;
    *HashtagFields;
};

# Represents the Queries record for the operation: findUserByUsername
public type FindUserByUsernameQueries record {
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("most_recent_tweet_id"|"pinned_tweet_id")[] expansions?;
};

# Expanded details for the URL specified in the User's profile, with start and end indices
public type UserEntitiesUrl record {
    # Array of URL entities found in user profile descriptions
    @constraint:Array {minLength: 1}
    UrlEntity[] urls?;
};

# Media information being attached to created Tweet. This is mutually exclusive from Quote Tweet Id, Poll, and Card URI
public type TweetCreateRequestMedia record {|
    # A list of Media Ids to be attached to a created Tweet
    @jsondata:Name {value: "media_ids"}
    MediaId[] mediaIds;
    # A list of User Ids to be tagged in the media for created Tweet
    @jsondata:Name {value: "tagged_user_ids"}
    UserId[] taggedUserIds?;
|};

# Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint.
@display {label: "Connection Config"}
public type ConnectionConfig record {|
    # Configurations related to client authentication
    http:BearerTokenConfig|OAuth2RefreshTokenGrantConfig auth;
    # The HTTP version understood by the client
    http:HttpVersion httpVersion = http:HTTP_2_0;
    # Configurations related to HTTP/1.x protocol
    http:ClientHttp1Settings http1Settings = {};
    # Configurations related to HTTP/2 protocol
    http:ClientHttp2Settings http2Settings = {};
    # The maximum time to wait (in seconds) for a response before closing the connection
    decimal timeout = 30;
    # The choice of setting `forwarded`/`x-forwarded` header
    string forwarded = "disable";
    # Configurations associated with Redirection
    http:FollowRedirects followRedirects?;
    # Configurations associated with request pooling
    http:PoolConfiguration poolConfig?;
    # HTTP caching related configurations
    http:CacheConfig cache = {};
    # Specifies the way of handling compression (`accept-encoding`) header
    http:Compression compression = http:COMPRESSION_AUTO;
    # Configurations associated with the behaviour of the Circuit Breaker
    http:CircuitBreakerConfig circuitBreaker?;
    # Configurations associated with retrying
    http:RetryConfig retryConfig?;
    # Configurations associated with cookies
    http:CookieConfig cookieConfig?;
    # Configurations associated with inbound response size limits
    http:ResponseLimitConfigs responseLimits = {};
    # SSL/TLS-related options
    http:ClientSecureSocket secureSocket?;
    # Proxy server related options
    http:ProxyConfig proxy?;
    # Provides settings related to client socket configuration
    http:ClientSocketConfig socketConfig = {};
    # Enables the inbound payload validation functionality which provided by the constraint package. Enabled by default
    boolean validation = true;
    # Enables relaxed data binding on the client side. When enabled, `nil` values are treated as optional, 
    # and absent fields are handled as `nilable` types. Enabled by default.
    boolean laxDataBinding = true;
|};

# Request schema for creating user retweets
public type UsersRetweetsCreateRequest record {|
    # ID of the tweet to retweet
    @jsondata:Name {value: "tweet_id"}
    TweetId tweetId;
|};

# A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`
@constraint:Array {maxLength: 2, minLength: 2}
public type Position decimal[];

# A response from deleting user-specified stream filtering rules
public type DeleteRulesRequest record {
    # IDs and values of all deleted user-specified stream filtering rules
    DeleteRulesRequestDelete delete;
};

# A request to add a user-specified stream filtering rule
public type AddRulesRequest record {
    # Array of rules to add
    RuleNoId[] add;
};

# The note content of the Tweet
public type NoteTweetText string;

# Response object for bookmark mutation operations with data and error details
public type BookmarkMutationResponse record {
    # Response data for bookmark mutation operations
    BookmarkMutationResponseData data?;
    # Array of error objects if the bookmark operation encountered issues
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Annotation inferred from the Tweet text
public type ContextAnnotation record {
    # Represents the data for the context annotation domain
    ContextAnnotationDomainFields domain;
    # Represents the data for the context annotation entity
    ContextAnnotationEntityFields entity;
};

# Response schema for creating user following relationship
public type UsersFollowingCreateResponse record {
    # Response data for user following creation operations
    UsersFollowingCreateResponseData data?;
    # Array of error objects encountered during the follow operation
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Response data for creating a retweet operation
public type UsersRetweetsCreateResponseData record {
    # Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers
    TweetId id?;
    # Indicates whether the retweet operation was successful
    boolean retweeted?;
};

# Metadata for paginated followers response including tokens and count
public type Get2UsersIdFollowersResponseMeta record {
    # Token for retrieving the previous page of followers results
    @jsondata:Name {value: "previous_token"}
    PreviousToken previousToken?;
    # Token for retrieving the next page of followers results
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # Number of followers returned in the current response
    @jsondata:Name {value: "result_count"}
    ResultCount resultCount?;
};

# Represent the portion of text recognized as a URL, and its start and end position within the text
public type UrlEntity record {
    *EntityIndicesInclusiveExclusive;
    *UrlFields;
};

# Geographic location information in GeoJSON Feature format
public type Geo record {
    # Bounding box coordinates [west, south, east, north] in decimal degrees
    @constraint:Array {maxLength: 4, minLength: 4}
    GeoBboxItemsNumber[] bbox;
    # A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object
    Point geometry?;
    # GeoJSON object type, always 'Feature'
    "Feature" 'type;
    # Additional properties associated with the geographic feature
    record {} properties;
};

# Represents the Queries record for the operation: searchStream
public type SearchStreamQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # The number of minutes of backfill requested
    @http:Query {name: "backfill_minutes"}
    int:Signed32 backfillMinutes?;
    # YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided
    @http:Query {name: "start_time"}
    string startTime?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided
    @http:Query {name: "end_time"}
    string endTime?;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
};

# Response containing tweets from a specific user
public type Get2UsersIdTweetsResponse record {
    # Array of tweet objects from the specified user
    @constraint:Array {minLength: 1}
    Tweet[] data?;
    # Metadata for user tweets response including pagination and result counts
    Get2UsersIdTweetsResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects if any issues occurred
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

public type UsersFollowingCreateResponseOk record {|
    *http:Ok;
    UsersFollowingCreateResponse body;
|};

# Represent the portion of text recognized as a User mention, and its start and end position within the text
public type MentionFields record {
    # Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers
    UserId id?;
    # The X handle (screen name) of this user
    UserName username;
};

# Response data for deleting a retweet operation
public type UsersRetweetsDeleteResponseData record {
    # Indicates whether the retweet deletion was successful
    boolean retweeted?;
};

# Response containing the authenticated user's profile information
public type Get2UsersMeResponse record {
    # The X User object
    User data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects if any issues occurred
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Represents the Queries record for the operation: findUsersById
public type FindUsersByIdQueries record {
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A list of User IDs, comma-separated. You can specify up to 100 IDs
    @constraint:Array {maxLength: 100, minLength: 1}
    UserId[] ids;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("most_recent_tweet_id"|"pinned_tweet_id")[] expansions?;
};

# Engagement metrics for the Tweet at the time of the request
public type TweetPublicMetrics record {
    # Number of times this Tweet has been liked
    @jsondata:Name {value: "like_count"}
    int likeCount;
    # Number of times this Tweet has been bookmarked
    @jsondata:Name {value: "bookmark_count"}
    int:Signed32 bookmarkCount;
    # Number of times this Tweet has been replied to
    @jsondata:Name {value: "reply_count"}
    int replyCount;
    # Number of times this Tweet has been quoted
    @jsondata:Name {value: "quote_count"}
    int quoteCount?;
    # Number of times this Tweet has been Retweeted
    @jsondata:Name {value: "retweet_count"}
    int retweetCount;
    # Number of times this Tweet has been viewed
    @jsondata:Name {value: "impression_count"}
    int:Signed32 impressionCount;
};

# Place ID being attached to the Tweet for geo location
public type TweetCreateRequestGeo record {|
    # The place ID to associate with the tweet's location
    @jsondata:Name {value: "place_id"}
    string placeId?;
|};

# A user-provided stream filtering rule
public type Rule record {
    # Unique identifier of this rule
    RuleId id?;
    # A tag meant for the labeling of user provided rules
    RuleTag tag?;
    # The filterlang value of the rule
    RuleValue value;
};

# Summary of rules request operation with multiple possible response formats
public type RulesRequestSummary RulesRequestSummaryOneOf1|RulesRequestSummaryRulesRequestSummaryOneOf12;

# Represents the Queries record for the operation: findTweetsById
public type FindTweetsByIdQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # A comma separated list of Post IDs. Up to 100 are allowed in a single request
    @constraint:Array {maxLength: 100, minLength: 1}
    TweetId[] ids;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
};

# Entities extracted from tweet note content including mentions, hashtags, and URLs
public type TweetNoteTweetEntities record {
    # Array of cashtag entities found in the tweet note
    @constraint:Array {minLength: 1}
    CashtagEntity[] cashtags?;
    # Array of URL entities found in the tweet note
    @constraint:Array {minLength: 1}
    UrlEntity[] urls?;
    # Array of hashtag entities found in the tweet note
    @constraint:Array {minLength: 1}
    HashtagEntity[] hashtags?;
    # Array of user mention entities found in the tweet note
    @constraint:Array {minLength: 1}
    MentionEntity[] mentions?;
};

# Represents the data for the context annotation entity
public type ContextAnnotationEntityFields record {
    # Name of the context annotation entity
    string name?;
    # Description of the context annotation entity
    string description?;
    # The unique id for a context annotation entity
    @constraint:String {pattern: re `^[0-9]{1,19}$`}
    string id;
};

# The location tagged on the Tweet, if the user provided one
public type TweetGeo record {
    # A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object
    Point coordinates?;
    # Unique identifier for the place associated with the Tweet
    @jsondata:Name {value: "place_id"}
    PlaceId placeId?;
};

# Represents the Queries record for the operation: findUserById
public type FindUserByIdQueries record {
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("most_recent_tweet_id"|"pinned_tweet_id")[] expansions?;
};

# Represents the Queries record for the operation: getRules
public type GetRulesQueries record {
    # This value is populated by passing the 'next_token' returned in a request to paginate through results
    @http:Query {name: "pagination_token"}
    string paginationToken?;
    # A comma-separated list of Rule IDs
    RuleId[] ids?;
    # The maximum number of results
    @http:Query {name: "max_results"}
    int:Signed32 maxResults = 1000;
};

# A validly formatted URL
public type Url string;

# Response object for user search operations with results and metadata
public type Get2UsersSearchResponse record {
    # Array of User objects matching the search criteria
    @constraint:Array {minLength: 1}
    User[] data?;
    # Metadata for paginating through user search results
    Get2UsersSearchResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of errors encountered during user search operation
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Response data for user following creation operations
public type UsersFollowingCreateResponseData record {
    # Indicates if the user is successfully being followed
    boolean following?;
    # Indicates if the follow request is pending approval
    @jsondata:Name {value: "pending_follow"}
    boolean pendingFollow?;
};

# Represents the Queries record for the operation: usersIdFollowers
public type UsersIdFollowersQueries record {
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # This parameter is used to get a specified 'page' of results
    @http:Query {name: "pagination_token"}
    PaginationToken32 paginationToken?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # The maximum number of results
    @http:Query {name: "max_results"}
    int:Signed32 maxResults?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("most_recent_tweet_id"|"pinned_tweet_id")[] expansions?;
};

# Response object for retrieving user information by username
public type Get2UsersByUsernameUsernameResponse record {
    # The X User object
    User data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects if the request encountered issues
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Represents the Queries record for the operation: tweetsRecentSearch
public type TweetsRecentSearchQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # One query/rule/filter for matching Posts. Refer to https://t.co/rulelength to identify the max query length
    @constraint:String {maxLength: 4096, minLength: 1}
    string query;
    # YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute)
    @http:Query {name: "end_time"}
    string endTime?;
    # Returns results with a Post ID greater than (that is, more recent than) the specified ID
    @http:Query {name: "since_id"}
    TweetId sinceId?;
    # This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified
    @http:Query {name: "next_token"}
    PaginationToken36 nextToken?;
    # YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute)
    @http:Query {name: "start_time"}
    string startTime?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified
    @http:Query {name: "pagination_token"}
    PaginationToken36 paginationToken?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # The maximum number of search results to be returned by a request
    @http:Query {name: "max_results"}
    int:Signed32 maxResults = 10;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
    # This order in which to return results
    @http:Query {name: "sort_order"}
    "recency"|"relevancy" sortOrder?;
    # Returns results with a Post ID less than (that is, older than) the specified ID
    @http:Query {name: "until_id"}
    TweetId untilId?;
};

# Represents the Queries record for the operation: addOrDeleteRules
public type AddOrDeleteRulesQueries record {
    # Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes
    @http:Query {name: "dry_run"}
    boolean dryRun?;
    # Delete All can be used to delete all of the rules associated this client app, it should be specified with no other parameters. Once deleted, rules cannot be recovered
    @http:Query {name: "delete_all"}
    boolean deleteAll?;
};

# A tag meant for the labeling of user provided rules
public type RuleTag string;

# Rules that matched a tweet in the filtered stream response
public type FilteredStreamingTweetResponseMatchingRules record {
    # Unique identifier of this rule
    RuleId id;
    # A tag meant for the labeling of user provided rules
    RuleTag tag?;
};

# Response object for creating a retweet operation
public type UsersRetweetsCreateResponse record {
    # Response data for creating a retweet operation
    UsersRetweetsCreateResponseData data?;
    # Array of error objects if the retweet creation failed
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Response object containing multiple tweets and related data
public type Get2TweetsResponse record {
    # Array of tweet objects returned by the request
    @constraint:Array {minLength: 1}
    Tweet[] data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of errors encountered during request processing
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Represent the portion of text recognized as a URL
public type UrlFields record {
    # The URL as displayed in the X client
    @jsondata:Name {value: "display_url"}
    string displayUrl?;
    # Array of images associated with the URL
    @constraint:Array {minLength: 1}
    UrlImage[] images?;
    # The fully expanded URL
    @jsondata:Name {value: "expanded_url"}
    Url expandedUrl?;
    # Fully resolved url
    @jsondata:Name {value: "unwound_url"}
    string unwoundUrl?;
    # Description of the URL landing page
    string description?;
    # Title of the page the URL points to
    string title?;
    # Unique identifier for associated media content
    @jsondata:Name {value: "media_key"}
    MediaKey mediaKey?;
    # A validly formatted URL
    Url url;
    # HTTP Status Code
    HttpStatusCode status?;
};

# Request object for creating a new tweet
public type TweetCreateRequest record {|
    # Place ID being attached to the Tweet for geo location
    TweetCreateRequestGeo geo?;
    # Nullcasted (promoted-only) Posts do not appear in the public timeline and are not served to followers
    boolean nullcast = false;
    # Exclusive Tweet for super followers
    @jsondata:Name {value: "for_super_followers_only"}
    boolean forSuperFollowersOnly = false;
    # ID of the tweet being quoted
    @jsondata:Name {value: "quote_tweet_id"}
    TweetId quoteTweetId?;
    # Link to take the conversation from the public timeline to a private Direct Message
    @jsondata:Name {value: "direct_message_deep_link"}
    string directMessageDeepLink?;
    # Card Uri Parameter. This is mutually exclusive from Quote Tweet Id, Poll, Media, and Direct Message Deep Link
    @jsondata:Name {value: "card_uri"}
    string cardUri?;
    # Media information being attached to created Tweet. This is mutually exclusive from Quote Tweet Id, Poll, and Card URI
    TweetCreateRequestMedia media?;
    # Poll options for a Tweet with a poll. This is mutually exclusive from Media, Quote Tweet Id, and Card URI
    TweetCreateRequestPoll poll?;
    # The content of the Tweet
    TweetText text?;
    # Tweet information of the Tweet being replied to
    TweetCreateRequestReply reply?;
    # Settings to indicate who can reply to the Tweet
    @jsondata:Name {value: "reply_settings"}
    "following"|"mentionedUsers"|"subscribers" replySettings?;
|};

# Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, subscribers, verified and following
public type ReplySettingsWithVerifiedUsers "everyone"|"mentionedUsers"|"following"|"other"|"subscribers"|"verified";

# Response for removing a user's like from a tweet
public type UsersLikesDeleteResponse record {
    # Response data for unlike tweet operation
    UsersLikesDeleteResponseData data?;
    # Array of errors encountered during request processing
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Represents the Queries record for the operation: findUsersByUsername
public type FindUsersByUsernameQueries record {
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A list of usernames, comma-separated
    @constraint:Array {maxLength: 100, minLength: 1}
    FindUsersByUsernameQueriesUsernamesItemsString[] usernames;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("most_recent_tweet_id"|"pinned_tweet_id")[] expansions?;
};

# Container for expanded objects referenced in the primary response data
public type Expansions record {
    # Array of expanded place objects referenced in the response
    @constraint:Array {minLength: 1}
    Place[] places?;
    # Array of expanded topic objects referenced in the response
    @constraint:Array {minLength: 1}
    Topic[] topics?;
    # Array of expanded poll objects referenced in the response
    @constraint:Array {minLength: 1}
    Poll[] polls?;
    # Array of expanded media objects referenced in the response
    @constraint:Array {minLength: 1}
    Media[] media?;
    # Array of expanded tweet objects referenced in the response
    @constraint:Array {minLength: 1}
    Tweet[] tweets?;
    # Array of expanded user objects referenced in the response
    @constraint:Array {minLength: 1}
    User[] users?;
};

# A base36 pagination token
@constraint:String {minLength: 1}
public type PaginationToken36 string;

# Response data confirming tweet deletion status
public type TweetDeleteResponseData record {
    # Boolean indicating whether the tweet was successfully deleted
    boolean deleted;
};

# A list of metadata found in the User's profile description
public type UserEntities record {
    # Contains extracted entities from tweet text including hashtags, mentions, URLs, cashtags, and annotations
    FullTextEntities description?;
    # Expanded details for the URL specified in the User's profile, with start and end indices
    UserEntitiesUrl url?;
};

public type ErrorProblemDefault record {|
    *http:DefaultStatusCodeResponse;
    Error|Problem body;
|};

# Specifies the type of attachments (if any) present in this Tweet
public type TweetAttachments record {
    # A list of Posts the media on this Tweet was originally posted in. For example, if the media on a tweet is re-used in another Tweet, this refers to the original, source Tweet
    @jsondata:Name {value: "media_source_tweet_id"}
    TweetId[] mediaSourceTweetId?;
    # A list of Media Keys for each one of the media attachments (if media are attached)
    @jsondata:Name {value: "media_keys"}
    MediaKey[] mediaKeys?;
    # A list of poll IDs (if polls are attached)
    @jsondata:Name {value: "poll_ids"}
    PollId[] pollIds?;
};

# Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive
public type EntityIndicesInclusiveInclusive record {
    # Index (zero-based) at which position this entity starts.  The index is inclusive
    @constraint:Int {minValue: 0}
    int 'start;
    # Index (zero-based) at which position this entity ends.  The index is inclusive
    @constraint:Int {minValue: 0}
    int end;
};

# Unique identifier of this User. The value must be the same as the authenticated user
public type UserIdMatchesAuthenticatedUser string;

# Response object containing comprehensive tweet search results
public type Get2TweetsSearchAllResponse record {
    # Array of Tweet objects matching the search query
    @constraint:Array {minLength: 1}
    Tweet[] data?;
    # Metadata for full archive Tweet search response pagination
    Get2TweetsSearchAllResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects encountered during the request processing
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Request object for adding a tweet to bookmarks
public type BookmarkAddRequest record {
    # ID of the tweet to be bookmarked
    @jsondata:Name {value: "tweet_id"}
    TweetId tweetId;
};

# Annotation for entities based on the Tweet text
public type FullTextEntitiesAnnotations record {
    *EntityIndicesInclusiveInclusive;
    *AnnotationData;
};

# Geographic place information with location details and metadata
public type Place record {
    # Geographic location information in GeoJSON Feature format
    Geo geo?;
    # Array of parent places that contain this location
    @jsondata:Name {value: "contained_within"}
    PlaceId[] containedWithin?;
    # The full name of the county in which this place exists
    string country?;
    # ISO country code for the place location
    @jsondata:Name {value: "country_code"}
    CountryCode countryCode?;
    # The full name of this place
    @jsondata:Name {value: "full_name"}
    string fullName;
    # The type classification of the place
    @jsondata:Name {value: "place_type"}
    PlaceType placeType?;
    # The human readable name of this place
    string name?;
    # The identifier for this place
    PlaceId id;
};

# Represents the Queries record for the operation: findMyUser
public type FindMyUserQueries record {
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("most_recent_tweet_id"|"pinned_tweet_id")[] expansions?;
};

# Metadata for reverse chronological timeline response with pagination info
public type Get2UsersIdTimelinesReverseChronologicalResponseMeta record {
    # The ID of the oldest Tweet in the timeline response
    @jsondata:Name {value: "oldest_id"}
    OldestId oldestId?;
    # Token for retrieving the previous page of timeline results
    @jsondata:Name {value: "previous_token"}
    PreviousToken previousToken?;
    # The ID of the newest Tweet in the timeline response
    @jsondata:Name {value: "newest_id"}
    NewestId newestId?;
    # Token for retrieving the next page of timeline results
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # The number of Tweets returned in the timeline response
    @jsondata:Name {value: "result_count"}
    ResultCount resultCount?;
};

# Represent the information for the URL image
public type UrlImage record {
    # The width of the media in pixels
    MediaWidth width?;
    # A validly formatted URL
    Url url?;
    # The height of the media in pixels
    MediaHeight height?;
};

@constraint:String {pattern: re `^[A-Za-z0-9_]{1,15}$`}
public type FindUsersByUsernameQueriesUsernamesItemsString string;

public type AddOrDeleteRulesResponseOk record {|
    *http:Ok;
    AddOrDeleteRulesResponse body;
|};

# Geographic place type classification
public type PlaceType "poi"|"neighborhood"|"city"|"admin"|"country"|"unknown";

# Represents the Queries record for the operation: sampleStream
public type SampleStreamQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # The number of minutes of backfill requested
    @http:Query {name: "backfill_minutes"}
    int:Signed32 backfillMinutes?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
};

# Response data for unfollowing a user operation
public type UsersFollowingDeleteResponseData record {
    # Indicates if the user is still being followed after the operation
    boolean following?;
};

# Complete Tweet object with all available fields and metadata
public type Tweet record {
    # Specifies the type of attachments (if any) present in this Tweet
    TweetAttachments attachments?;
    # Creation time of the Tweet
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # This is deprecated
    string 'source?;
    # Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country)
    TweetWithheld withheld?;
    # Tweet editing controls and permissions
    @jsondata:Name {value: "edit_controls"}
    TweetEditControls editControls?;
    # The location tagged on the Tweet, if the user provided one
    TweetGeo geo?;
    # Unique identifier of the conversation thread
    @jsondata:Name {value: "conversation_id"}
    TweetId conversationId?;
    # A list of Tweet Ids in this Tweet chain
    @jsondata:Name {value: "edit_history_tweet_ids"}
    TweetId[] editHistoryTweetIds?;
    # User ID of the user being replied to
    @jsondata:Name {value: "in_reply_to_user_id"}
    UserId inReplyToUserId?;
    # Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers
    TweetId id?;
    # The content of the Tweet
    TweetText text?;
    # Language of the Tweet, if detected by X. Returned as a BCP47 language tag
    string lang?;
    # Settings controlling who can reply to the Tweet
    @jsondata:Name {value: "reply_settings"}
    ReplySettingsWithVerifiedUsers replySettings?;
    # A list of Posts this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent
    @jsondata:Name {value: "referenced_tweets"}
    TweetReferencedTweets[] referencedTweets?;
    # Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences
    @jsondata:Name {value: "possibly_sensitive"}
    boolean possiblySensitive?;
    # Public engagement metrics for the Tweet
    @jsondata:Name {value: "public_metrics"}
    TweetPublicMetrics publicMetrics?;
    # Private engagement metrics for the Tweet author
    @jsondata:Name {value: "non_public_metrics"}
    TweetNonPublicMetrics nonPublicMetrics?;
    # Extended Tweet content information
    @jsondata:Name {value: "note_tweet"}
    TweetNoteTweet noteTweet?;
    # Contextual annotations and entity classifications for the Tweet
    @jsondata:Name {value: "context_annotations"}
    ContextAnnotation[] contextAnnotations?;
    # Contains extracted entities from tweet text including hashtags, mentions, URLs, cashtags, and annotations
    FullTextEntities entities?;
    # Engagement metrics for promoted Tweets
    @jsondata:Name {value: "promoted_metrics"}
    TweetPromotedMetrics promotedMetrics?;
    # The scopes for this tweet
    TweetScopes scopes?;
    # Unique identifier of the Tweet author
    @jsondata:Name {value: "author_id"}
    UserId authorId?;
    # Engagement metrics for organic Tweet performance
    @jsondata:Name {value: "organic_metrics"}
    TweetOrganicMetrics organicMetrics?;
    # The X handle (screen name) of this user
    UserName username?;
};

# The newest id in this response
public type NewestId string;

# Summary of stream filtering rules deletion results
public type RulesRequestSummaryRulesRequestSummaryOneOf12 record {
    # Number of user-specified stream filtering rules that were deleted
    int:Signed32 deleted;
    # Number of user-specified stream filtering rules that were not deleted
    @jsondata:Name {value: "not_deleted"}
    int:Signed32 notDeleted;
};

# Response schema for retrieving a user's liked Tweets
public type Get2UsersIdLikedTweetsResponse record {
    # Array of Tweet objects that the user has liked
    @constraint:Array {minLength: 1}
    Tweet[] data?;
    # Metadata for paginated response of user's liked tweets
    Get2UsersIdLikedTweetsResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects encountered during the request
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Unique identifier of this poll
@constraint:String {pattern: re `^[0-9]{1,19}$`}
public type PollId string;

# Response schema for recent Tweet search results
public type Get2TweetsSearchRecentResponse record {
    # Array of Tweet objects matching the search criteria
    @constraint:Array {minLength: 1}
    Tweet[] data?;
    # Metadata for recent Tweet search response pagination
    Get2TweetsSearchRecentResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of errors that occurred during the request processing
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# The filterlang value of the rule
public type RuleValue string;

# Represent the portion of text recognized as a Cashtag, and its start and end position within the text
public type CashtagFields record {
    # The cashtag symbol without the dollar sign prefix
    string tag;
};

# Metadata for recent Tweet search response pagination
public type Get2TweetsSearchRecentResponseMeta record {
    # ID of the oldest Tweet in the search results
    @jsondata:Name {value: "oldest_id"}
    OldestId oldestId?;
    # ID of the newest Tweet in the search results
    @jsondata:Name {value: "newest_id"}
    NewestId newestId?;
    # Token for retrieving next page of search results
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # Number of Tweets returned in search results
    @jsondata:Name {value: "result_count"}
    ResultCount resultCount?;
};

# Organic nonpublic engagement metrics for the Tweet at the time of the request
public type TweetOrganicMetrics record {
    # Number of times this Tweet has been liked
    @jsondata:Name {value: "like_count"}
    int likeCount;
    # Number of times this Tweet has been replied to
    @jsondata:Name {value: "reply_count"}
    int replyCount;
    # Number of times this Tweet has been Retweeted
    @jsondata:Name {value: "retweet_count"}
    int retweetCount;
    # Number of times this Tweet has been viewed
    @jsondata:Name {value: "impression_count"}
    int impressionCount;
};

# Response data for creating a like operation
public type UsersLikesCreateResponseData record {
    # Indicates whether the like operation was successful
    boolean liked?;
};

# A base32 pagination token
@constraint:String {minLength: 16}
public type PaginationToken32 string;

# Metadata for full archive Tweet search response pagination
public type Get2TweetsSearchAllResponseMeta record {
    # ID of the oldest Tweet in the archive search results
    @jsondata:Name {value: "oldest_id"}
    OldestId oldestId?;
    # ID of the newest Tweet in the archive search results
    @jsondata:Name {value: "newest_id"}
    NewestId newestId?;
    # Token for retrieving next page of archive search results
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # Number of tweets returned in the search results
    @jsondata:Name {value: "result_count"}
    ResultCount resultCount?;
};

# Response object containing a user's bookmarked tweets with metadata
public type Get2UsersIdBookmarksResponse record {
    # Array of bookmarked tweet objects
    @constraint:Array {minLength: 1}
    Tweet[] data?;
    # Metadata for user bookmarks response including pagination tokens and count
    Get2UsersIdBookmarksResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects encountered while retrieving bookmarks
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Poll options for a Tweet with a poll. This is mutually exclusive from Media, Quote Tweet Id, and Card URI
public type TweetCreateRequestPoll record {|
    # Duration of the poll in minutes
    @jsondata:Name {value: "duration_minutes"}
    int:Signed32 durationMinutes;
    # Array of poll choice options (2-4 items, 1-25 characters each)
    @constraint:Array {maxLength: 4, minLength: 2}
    TweetCreateRequestPollOptionsItemsString[] options;
    # Settings to indicate who can reply to the Tweet
    @jsondata:Name {value: "reply_settings"}
    "following"|"mentionedUsers" replySettings?;
|};

public type BookmarkMutationResponseOk record {|
    *http:Ok;
    BookmarkMutationResponse body;
|};

# The width of the media in pixels
@constraint:Int {minValue: 0}
public type MediaWidth int;

# Represent the portion of text recognized as a Hashtag, and its start and end position within the text
public type HashtagFields record {
    # The text of the Hashtag
    string tag;
};

# The oldest id in this response
public type OldestId string;

# Metadata for user tweets response including pagination and result counts
public type Get2UsersIdTweetsResponseMeta record {
    # ID of the oldest Tweet in the response
    @jsondata:Name {value: "oldest_id"}
    OldestId oldestId?;
    # Token for retrieving the previous page of results
    @jsondata:Name {value: "previous_token"}
    PreviousToken previousToken?;
    # ID of the newest Tweet in the response
    @jsondata:Name {value: "newest_id"}
    NewestId newestId?;
    # Token for retrieving the next page of results
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # Number of results returned in the current response
    @jsondata:Name {value: "result_count"}
    ResultCount resultCount?;
};

# The identifier for this place
public type PlaceId string;

# Represents the data for the context annotation domain
public type ContextAnnotationDomainFields record {
    # Name of the context annotation domain
    string name?;
    # Description of the context annotation domain
    string description?;
    # The unique id for a context annotation domain
    @constraint:String {pattern: re `^[0-9]{1,19}$`}
    string id;
};

# A user-provided stream filtering rule
public type RuleNoId record {
    # A tag meant for the labeling of user provided rules
    RuleTag tag?;
    # The filterlang value of the rule
    RuleValue value;
};

# Response object for user's reverse chronological timeline
public type Get2UsersIdTimelinesReverseChronologicalResponse record {
    # Array of Tweet objects from the user's timeline
    @constraint:Array {minLength: 1}
    Tweet[] data?;
    # Metadata for reverse chronological timeline response with pagination info
    Get2UsersIdTimelinesReverseChronologicalResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Response for batch user lookup requests
public type Get2UsersByResponse record {
    # Array of user objects returned
    @constraint:Array {minLength: 1}
    User[] data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of errors encountered during request
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Media attachment object containing metadata and type information
public type Media record {
    # The width of the media in pixels
    MediaWidth width?;
    # Type of media (photo, video, animated_gif)
    string 'type;
    # Unique identifier for the media attachment
    @jsondata:Name {value: "media_key"}
    MediaKey mediaKey?;
    # The height of the media in pixels
    MediaHeight height?;
};

# A list of metrics for this User
public type UserPublicMetrics record {
    # The number of Posts (including Retweets) posted by this User
    @jsondata:Name {value: "tweet_count"}
    int tweetCount;
    # The number of likes created by this User
    @jsondata:Name {value: "like_count"}
    int likeCount?;
    # Number of Users this User is following
    @jsondata:Name {value: "following_count"}
    int followingCount;
    # The number of lists that include this User
    @jsondata:Name {value: "listed_count"}
    int listedCount;
    # Number of Users who are following this User
    @jsondata:Name {value: "followers_count"}
    int followersCount;
};

# Response object for deleting user retweets
public type UsersRetweetsDeleteResponse record {
    # Response data for deleting a retweet operation
    UsersRetweetsDeleteResponseData data?;
    # Array of error objects encountered during retweet deletion
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

@constraint:String {maxLength: 25, minLength: 1}
public type TweetCreateRequestPollOptionsItemsString string;

# Tweet information of the Tweet being replied to
public type TweetCreateRequestReply record {|
    # A list of User Ids to be excluded from the reply Tweet
    @jsondata:Name {value: "exclude_reply_user_ids"}
    UserId[] excludeReplyUserIds?;
    # ID of the tweet being replied to
    @jsondata:Name {value: "in_reply_to_tweet_id"}
    TweetId inReplyToTweetId;
|};

# A response from modifying user-specified stream filtering rules
public type AddOrDeleteRulesResponse record {
    # All user-specified stream filtering rules that were created
    Rule[] data?;
    # Metadata information for rules API responses
    RulesResponseMetadata meta;
    # Array of error objects encountered during rules operation
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Represents the Queries record for the operation: searchUserByQuery
public type SearchUserByQueryQueries record {
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # TThe the query string by which to query for users
    UserSearchQuery query;
    # The maximum number of results
    @http:Query {name: "max_results"}
    int:Signed32 maxResults = 100;
    # This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified
    @http:Query {name: "next_token"}
    PaginationToken36 nextToken?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("most_recent_tweet_id"|"pinned_tweet_id")[] expansions?;
};

public type UsersRetweetsCreateResponseOk record {|
    *http:Ok;
    UsersRetweetsCreateResponse body;
|};

# IDs and values of all deleted user-specified stream filtering rules
public type DeleteRulesRequestDelete record {
    # Values of all deleted user-specified stream filtering rules
    RuleValue[] values?;
    # IDs of all deleted user-specified stream filtering rules
    RuleId[] ids?;
};

# Nonpublic engagement metrics for the Tweet at the time of the request
public type TweetNonPublicMetrics record {
    # Number of times this Tweet has been viewed
    @jsondata:Name {value: "impression_count"}
    int:Signed32 impressionCount?;
};

# The unique identifier of this Media
@constraint:String {pattern: re `^[0-9]{1,19}$`}
public type MediaId string;

# Controls and metadata related to tweet editing capabilities
public type TweetEditControls record {
    # Indicates if this Tweet is eligible to be edited
    @jsondata:Name {value: "is_edit_eligible"}
    boolean isEditEligible;
    # Number of times this Tweet can be edited
    @jsondata:Name {value: "edits_remaining"}
    int editsRemaining;
    # Time when Tweet is no longer editable
    @jsondata:Name {value: "editable_until"}
    string editableUntil;
};

# Promoted nonpublic engagement metrics for the Tweet at the time of the request
public type TweetPromotedMetrics record {
    # Number of times this Tweet has been liked
    @jsondata:Name {value: "like_count"}
    int:Signed32 likeCount?;
    # Number of times this Tweet has been replied to
    @jsondata:Name {value: "reply_count"}
    int:Signed32 replyCount?;
    # Number of times this Tweet has been Retweeted
    @jsondata:Name {value: "retweet_count"}
    int:Signed32 retweetCount?;
    # Number of times this Tweet has been viewed
    @jsondata:Name {value: "impression_count"}
    int:Signed32 impressionCount?;
};

# Response schema for retrieving users followed by a specific user
public type Get2UsersIdFollowingResponse record {
    # Array of user objects representing followed users
    @constraint:Array {minLength: 1}
    User[] data?;
    # Metadata schema for users following response pagination and counts
    Get2UsersIdFollowingResponseMeta meta?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects encountered during the request
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807)
public type Problem record {
    # Detailed description of the error or problem
    string detail?;
    # Brief title or summary of the error
    string title;
    # URI reference identifying the problem type
    string 'type;
    # HTTP status code associated with the problem
    int status?;
};

public type UsersLikesCreateResponseOk record {|
    *http:Ok;
    UsersLikesCreateResponse body;
|};

# Response object containing created tweet data and potential errors
public type TweetCreateResponse record {
    # Response data object containing details of the newly created tweet
    TweetCreateResponseData data?;
    # Array of error objects if tweet creation encountered issues
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# The height of the media in pixels
@constraint:Int {minValue: 0}
public type MediaHeight int;

# Metadata for paginating through user search results
public type Get2UsersSearchResponseMeta record {
    # Token to retrieve the previous page of search results
    @jsondata:Name {value: "previous_token"}
    PreviousToken previousToken?;
    # Token to retrieve the next page of search results
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
};

# Response object containing user data, expansions, and potential errors
public type Get2UsersIdResponse record {
    # The X User object
    User data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects if user retrieval encountered issues
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# The X User object
public type User record {
    # Unique identifier of the user's pinned tweet
    @jsondata:Name {value: "pinned_tweet_id"}
    TweetId pinnedTweetId?;
    # Returns detailed information about the relationship between two users
    @jsondata:Name {value: "connection_status"}
    ("follow_request_received"|"follow_request_sent"|"blocking"|"followed_by"|"following"|"muting")[] connectionStatus?;
    # Public engagement metrics for the user account
    @jsondata:Name {value: "public_metrics"}
    UserPublicMetrics publicMetrics?;
    # Indicate if this User is a verified X User
    boolean verified?;
    # Creation time of this User
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # The text of this User's profile description (also known as bio), if the User provided one
    string description?;
    # The URL to the profile image for this User
    @jsondata:Name {value: "profile_image_url"}
    string profileImageUrl?;
    # Indicates if you can send a DM to this User
    @jsondata:Name {value: "receives_your_dm"}
    boolean receivesYourDm?;
    # The X Blue verified type of the user, eg: blue, government, business or none
    @jsondata:Name {value: "verified_type"}
    "blue"|"government"|"business"|"none" verifiedType?;
    # Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country)
    UserWithheld withheld?;
    # The URL specified in the User's profile
    string url?;
    # Unique identifier of the user's most recently posted tweet
    @jsondata:Name {value: "most_recent_tweet_id"}
    TweetId mostRecentTweetId?;
    # Indicates if this User has chosen to protect their Posts (in other words, if this User's Posts are private)
    boolean protected?;
    # A list of metadata found in the User's profile description
    UserEntities entities?;
    # The friendly name of this User, as shown on their profile
    string name;
    # The location specified in the User's profile, if the User provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries
    string location?;
    # Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers
    UserId id;
    # The X Blue subscription type of the user, eg: Basic, Premium, PremiumPlus or None
    @jsondata:Name {value: "subscription_type"}
    "Basic"|"Premium"|"PremiumPlus"|"None" subscriptionType?;
    # The X handle (screen name) of this user
    UserName username;
};

# Represents the Queries record for the operation: tweetsFullarchiveSearch
public type TweetsFullarchiveSearchQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # One query/rule/filter for matching Posts. Refer to https://t.co/rulelength to identify the max query length
    @constraint:String {maxLength: 4096, minLength: 1}
    string query;
    # YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute)
    @http:Query {name: "end_time"}
    string endTime?;
    # Returns results with a Post ID greater than (that is, more recent than) the specified ID
    @http:Query {name: "since_id"}
    TweetId sinceId?;
    # This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified
    @http:Query {name: "next_token"}
    PaginationToken36 nextToken?;
    # YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute)
    @http:Query {name: "start_time"}
    string startTime?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified
    @http:Query {name: "pagination_token"}
    PaginationToken36 paginationToken?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # The maximum number of search results to be returned by a request
    @http:Query {name: "max_results"}
    int:Signed32 maxResults = 10;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
    # This order in which to return results
    @http:Query {name: "sort_order"}
    "recency"|"relevancy" sortOrder?;
    # Returns results with a Post ID less than (that is, older than) the specified ID
    @http:Query {name: "until_id"}
    TweetId untilId?;
};

# A Tweet or error that can be returned by the streaming Tweet API. The values returned with a successful streamed Tweet includes the user provided rules that the Tweet matched
public type FilteredStreamingTweetResponse record {
    # Complete Tweet object with all available fields and metadata
    Tweet data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # The list of rules which matched the Tweet
    @jsondata:Name {value: "matching_rules"}
    FilteredStreamingTweetResponseMatchingRules[] matchingRules?;
    # Array of error objects encountered during the request processing
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# The next token
@constraint:String {minLength: 1}
public type NextToken string;

# Metadata information for rules API responses
public type RulesResponseMetadata record {
    # Summary of rules request operation with multiple possible response formats
    RulesRequestSummary summary?;
    # Token to retrieve the next page of rules
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # Number of Rules in result set
    @jsondata:Name {value: "result_count"}
    int:Signed32 resultCount?;
    # Timestamp when the rules request was sent
    string sent;
};

# Represents the data for the annotation
public type AnnotationData record {
    # Confidence factor for annotation type
    @constraint:Number {minValue: 0, maxValue: 1}
    decimal probability?;
    # Text used to determine annotation
    @jsondata:Name {value: "normalized_text"}
    string normalizedText?;
    # Annotation type
    string 'type?;
};

# The content of the Tweet
public type TweetText string;

# Unique identifier of this rule
@constraint:String {pattern: re `^[0-9]{1,19}$`}
public type RuleId string;

# Metadata for user bookmarks response including pagination tokens and count
public type Get2UsersIdBookmarksResponseMeta record {
    # Token for accessing the previous page of bookmarks results
    @jsondata:Name {value: "previous_token"}
    PreviousToken previousToken?;
    # Token for accessing the next page of bookmarks results
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # Total number of bookmarks returned in the current response
    @jsondata:Name {value: "result_count"}
    ResultCount resultCount?;
};

# A summary of the results of the addition of user-specified stream filtering rules
public type RulesRequestSummaryOneOf1 record {
    # Number of valid user-specified stream filtering rules
    int:Signed32 valid;
    # Number of user-specified stream filtering rules that were not created
    @jsondata:Name {value: "not_created"}
    int:Signed32 notCreated;
    # Number of user-specified stream filtering rules that were created
    int:Signed32 created;
    # Number of invalid user-specified stream filtering rules
    int:Signed32 invalid;
};

# The text of a poll choice
@constraint:String {maxLength: 25, minLength: 1}
public type PollOptionLabel string;

# Request object for either adding or deleting streaming rules
public type AddOrDeleteRulesRequest AddRulesRequest|DeleteRulesRequest;

# Response containing streaming rules data and metadata
public type RulesLookupResponse record {
    # Array of streaming rule objects
    Rule[] data?;
    # Metadata information for rules API responses
    RulesResponseMetadata meta;
};

# Response data for bookmark mutation operations
public type BookmarkMutationResponseData record {
    # Boolean indicating the current bookmark status after the operation
    boolean bookmarked?;
};

# Response data object containing details of the newly created tweet
public type TweetCreateResponseData record {
    # Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers
    TweetId id;
    # The content of the Tweet
    TweetText text;
};

# The Media Key identifier for this attachment
@constraint:String {pattern: re `^([0-9]+)_([0-9]+)$`}
public type MediaKey string;

# Represents the Queries record for the operation: usersIdFollowing
public type UsersIdFollowingQueries record {
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # This parameter is used to get a specified 'page' of results
    @http:Query {name: "pagination_token"}
    PaginationToken32 paginationToken?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # The maximum number of results
    @http:Query {name: "max_results"}
    int:Signed32 maxResults?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("most_recent_tweet_id"|"pinned_tweet_id")[] expansions?;
};

# Response object for creating a user like operation
public type UsersLikesCreateResponse record {
    # Response data for creating a like operation
    UsersLikesCreateResponseData data?;
    # Array of error objects encountered during like creation
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Information about tweets referenced by another tweet
public type TweetReferencedTweets record {
    # Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers
    TweetId id;
    # Type of tweet reference: retweeted, quoted, or replied_to
    "retweeted"|"quoted"|"replied_to" 'type;
};

# Represents the Queries record for the operation: getUsersIdBookmarks
public type GetUsersIdBookmarksQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # This parameter is used to get the next 'page' of results
    @http:Query {name: "pagination_token"}
    PaginationToken36 paginationToken?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # The maximum number of results
    @http:Query {name: "max_results"}
    int:Signed32 maxResults?;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
};

# Contains extracted entities from tweet text including hashtags, mentions, URLs, cashtags, and annotations
public type FullTextEntities record {
    # Array of cashtag entities found in the tweet text
    @constraint:Array {minLength: 1}
    CashtagEntity[] cashtags?;
    # Array of URL entities found in the tweet text
    @constraint:Array {minLength: 1}
    UrlEntity[] urls?;
    # Array of hashtag entities found in the tweet text
    @constraint:Array {minLength: 1}
    HashtagEntity[] hashtags?;
    # Array of user mention entities found in the tweet text
    @constraint:Array {minLength: 1}
    MentionEntity[] mentions?;
    # Array of annotation entities found in the tweet text
    @constraint:Array {minLength: 1}
    FullTextEntitiesAnnotations[] annotations?;
};

# OAuth2 Refresh Token Grant Configs
public type OAuth2RefreshTokenGrantConfig record {|
    *http:OAuth2RefreshTokenGrantConfig;
    # Refresh URL
    string refreshUrl = "https://api.twitter.com/2/oauth2/token";
|};

# Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive
public type EntityIndicesInclusiveExclusive record {
    # Index (zero-based) at which position this entity starts.  The index is inclusive
    @constraint:Int {minValue: 0}
    int 'start;
    # Index (zero-based) at which position this entity ends.  The index is exclusive
    @constraint:Int {minValue: 0}
    int end;
};

# Unique identifier of this Topic
public type TopicId string;

# Describes a choice in a Poll object
public type PollOption record {
    # Number of users who voted for this choice
    int votes;
    # The text of a poll choice
    PollOptionLabel label;
    # Position of this choice in the poll
    int position;
};

# A two-letter ISO 3166-1 alpha-2 country code
@constraint:String {pattern: re `^[A-Z]{2}$`}
public type CountryCode string;

# The topic of a Space, as selected by its creator
public type Topic record {
    # The name of the given topic
    string name;
    # The description of the given topic
    string description?;
    # Unique identifier of this Topic
    TopicId id;
};

# The the search string by which to query for users
@constraint:String {pattern: re `^[A-Za-z0-9_]{1,32}$`}
public type UserSearchQuery string;

# Metadata schema for users following response pagination and counts
public type Get2UsersIdFollowingResponseMeta record {
    # Token for retrieving the previous page of following users
    @jsondata:Name {value: "previous_token"}
    PreviousToken previousToken?;
    # Token for retrieving the next page of following users
    @jsondata:Name {value: "next_token"}
    NextToken nextToken?;
    # Number of users returned in the following response
    @jsondata:Name {value: "result_count"}
    ResultCount resultCount?;
};

# Represents the Queries record for the operation: findTweetById
public type FindTweetByIdQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
};

# Entity representing a user mention with indices and mention fields
public type MentionEntity record {
    *EntityIndicesInclusiveExclusive;
    *MentionFields;
};

# The X handle (screen name) of this user
@constraint:String {pattern: re `^[A-Za-z0-9_]{1,15}$`}
public type UserName string;

# Response object returned when unfollowing a user
public type UsersFollowingDeleteResponse record {
    # Response data for unfollowing a user operation
    UsersFollowingDeleteResponseData data?;
    # Array of error objects if the unfollow operation failed
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Request schema for creating a user like with required tweet ID
public type UsersLikesCreateRequest record {
    # The ID of the tweet to like
    @jsondata:Name {value: "tweet_id"}
    TweetId tweetId;
};

# Represents the Queries record for the operation: usersIdTweets
public type UsersIdTweetsQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. The until_id parameter takes precedence if it is also specified
    @http:Query {name: "end_time"}
    string endTime?;
    # The minimum Post ID to be included in the result set. This parameter takes precedence over start_time if both are specified
    @http:Query {name: "since_id"}
    TweetId sinceId?;
    # YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. The since_id parameter takes precedence if it is also specified
    @http:Query {name: "start_time"}
    string startTime?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # This parameter is used to get the next 'page' of results
    @http:Query {name: "pagination_token"}
    PaginationToken36 paginationToken?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # The maximum number of results
    @http:Query {name: "max_results"}
    int:Signed32 maxResults?;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # The set of entities to exclude (e.g. 'replies' or 'retweets')
    @constraint:Array {minLength: 1}
    ("replies"|"retweets")[] exclude?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
    # The maximum Post ID to be included in the result set. This parameter takes precedence over end_time if both are specified
    @http:Query {name: "until_id"}
    TweetId untilId?;
};

# Response object for tweet deletion operations
public type TweetDeleteResponse record {
    # Response data confirming tweet deletion status
    TweetDeleteResponseData data?;
    # Array of errors that occurred during the tweet deletion request
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Request object for following a user
public type UsersFollowingCreateRequest record {
    # The ID of the user to follow
    @jsondata:Name {value: "target_user_id"}
    UserId targetUserId;
};

# Standard error object containing error code and message
public type Error record {
    # Numeric error code identifying the type of error
    int:Signed32 code;
    # Human-readable error message describing the issue
    string message;
};

# A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object
public type Point record {
    # A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`
    Position coordinates;
    # Geometry type identifier, always 'Point'
    "Point" 'type;
};

# Response data for unlike tweet operation
public type UsersLikesDeleteResponseData record {
    # Indicates whether the tweet is currently liked by the user
    boolean liked?;
};

# Real-time streaming response containing tweet data
public type StreamingTweetResponse record {
    # Complete Tweet object with all available fields and metadata
    Tweet data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects encountered during streaming
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# The scopes for this tweet
public type TweetScopes record {
    # Indicates if this Tweet is viewable by followers without the Tweet ID
    boolean followers?;
};

# Response containing a single tweet by ID
public type Get2TweetsIdResponse record {
    # Complete Tweet object with all available fields and metadata
    Tweet data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects encountered during request processing
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};

# Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country)
public type TweetWithheld record {
    # Indicates if the content is being withheld for on the basis of copyright infringement
    boolean copyright;
    # Indicates whether the content being withheld is the `tweet` or a `user`
    "tweet"|"user" scope?;
    # Provides a list of countries where this content is not available
    @jsondata:Name {value: "country_codes"}
    CountryCode[] countryCodes;
};

# Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers
@constraint:String {pattern: re `^[0-9]{1,19}$`}
public type UserId string;

# Represent a Poll attached to a Tweet
public type Poll record {
    # Current voting status of the poll (open or closed)
    @jsondata:Name {value: "voting_status"}
    "open"|"closed" votingStatus?;
    # Duration of the poll in minutes (5-10080)
    @jsondata:Name {value: "duration_minutes"}
    int:Signed32 durationMinutes?;
    # Date and time when the poll ends
    @jsondata:Name {value: "end_datetime"}
    string endDatetime?;
    # Array of poll options (2-4 items)
    @constraint:Array {maxLength: 4, minLength: 2}
    PollOption[] options;
    # Unique identifier of this poll
    PollId id;
};

# Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country)
public type UserWithheld record {
    # Indicates that the content being withheld is a `user`
    "user" scope?;
    # Provides a list of countries where this content is not available
    @jsondata:Name {value: "country_codes"}
    CountryCode[] countryCodes;
};

# Represents the Queries record for the operation: usersIdTimeline
public type UsersIdTimelineQueries record {
    # A comma separated list of Poll fields to display
    @http:Query {name: "poll.fields"}
    ("duration_minutes"|"end_datetime"|"id"|"options"|"voting_status")[] pollFields?;
    # A comma separated list of Tweet fields to display
    @http:Query {name: "tweet.fields"}
    ("attachments"|"author_id"|"card_uri"|"context_annotations"|"conversation_id"|"created_at"|"edit_controls"|"edit_history_tweet_ids"|"entities"|"geo"|"id"|"in_reply_to_user_id"|"lang"|"non_public_metrics"|"note_tweet"|"organic_metrics"|"possibly_sensitive"|"promoted_metrics"|"public_metrics"|"referenced_tweets"|"reply_settings"|"scopes"|"source"|"text"|"username"|"withheld")[] tweetFields?;
    # YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. The until_id parameter takes precedence if it is also specified
    @http:Query {name: "end_time"}
    string endTime?;
    # The minimum Post ID to be included in the result set. This parameter takes precedence over start_time if both are specified
    @http:Query {name: "since_id"}
    TweetId sinceId?;
    # YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. The since_id parameter takes precedence if it is also specified
    @http:Query {name: "start_time"}
    string startTime?;
    # A comma separated list of User fields to display
    @http:Query {name: "user.fields"}
    ("connection_status"|"created_at"|"description"|"entities"|"id"|"location"|"most_recent_tweet_id"|"name"|"pinned_tweet_id"|"profile_image_url"|"protected"|"public_metrics"|"receives_your_dm"|"subscription_type"|"url"|"username"|"verified"|"verified_type"|"withheld")[] userFields?;
    # This parameter is used to get the next 'page' of results
    @http:Query {name: "pagination_token"}
    PaginationToken36 paginationToken?;
    # A comma separated list of Media fields to display
    @http:Query {name: "media.fields"}
    ("alt_text"|"duration_ms"|"height"|"media_key"|"non_public_metrics"|"organic_metrics"|"preview_image_url"|"promoted_metrics"|"public_metrics"|"type"|"url"|"variants"|"width")[] mediaFields?;
    # The maximum number of results
    @http:Query {name: "max_results"}
    int:Signed32 maxResults?;
    # A comma separated list of Place fields to display
    @http:Query {name: "place.fields"}
    ("contained_within"|"country"|"country_code"|"full_name"|"geo"|"id"|"name"|"place_type")[] placeFields?;
    # The set of entities to exclude (e.g. 'replies' or 'retweets')
    ("replies"|"retweets")[] exclude?;
    # A comma separated list of fields to expand
    @constraint:Array {minLength: 1}
    ("attachments.media_keys"|"attachments.media_source_tweet"|"attachments.poll_ids"|"author_id"|"edit_history_tweet_ids"|"entities.mentions.username"|"geo.place_id"|"in_reply_to_user_id"|"entities.note.mentions.username"|"referenced_tweets.id"|"referenced_tweets.id.author_id"|"author_screen_name")[] expansions?;
    # The maximum Post ID to be included in the result set. This parameter takes precedence over end_time if both are specified
    @http:Query {name: "until_id"}
    TweetId untilId?;
};

# Response schema for retrieving multiple user objects from Twitter API v2
public type Get2UsersResponse record {
    # Array of User objects returned by the request
    @constraint:Array {minLength: 1}
    User[] data?;
    # Container for expanded objects referenced in the primary response data
    Expansions includes?;
    # Array of error objects encountered during request processing
    @constraint:Array {minLength: 1}
    Problem[] errors?;
};
